import xarray as xr
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import skew, kurtosis, t
import os

# Function to perform statistical analysis and plot heatmaps
def basic_statistical_analysis_and_plot(file_path, sensor_names, selected_stats):
    if not os.path.isfile(file_path):
        print(f"Error: File {file_path} does not exist.")
        return None

    try:
        ds = xr.open_dataset(file_path, engine='h5netcdf', phony_dims='sort')
    except Exception as e:
        print(f"Error opening file: {e}")
        return None

    # Dictionary to store statistics
    stats = {}

    # Dictionary to map statistics names to their respective calculation functions
    stats_functions = {
        'mean': np.nanmean,
        'median': np.nanmedian,
        'std_dev': np.nanstd,
        'min': np.nanmin,
        'max': np.nanmax,
        'variance': np.nanvar,
        'skewness': lambda x: skew(x, nan_policy='omit'),
        'kurtosis': lambda x: kurtosis(x, nan_policy='omit'),
        'conf_interval_low': lambda x: t.interval(0.95, len(x)-1, loc=np.nanmean(x), scale=np.nanstd(x)/np.sqrt(len(x)))[0],
        'conf_interval_high': lambda x: t.interval(0.95, len(x)-1, loc=np.nanmean(x), scale=np.nanstd(x)/np.sqrt(len(x)))[1]
    }

    for sensor_name in sensor_names:
        if sensor_name in ds.data_vars:
            data = ds[sensor_name].values.flatten()  # Flatten array

            # Check if the data is numeric and contains finite values
            if np.issubdtype(data.dtype, np.number):
                data = data[np.isfinite(data)]  # Remove infinite values

                # Store the selected statistics
                stats[sensor_name] = {stat: stats_functions[stat](data) for stat in selected_stats}
            else:
                print(f"Variable {sensor_name} is not numeric or has unsupported data type.")
        else:
            print(f"Variable {sensor_name} is not found in the dataset.")

    # Create separate heatmaps for each sensor
    for sensor_name, stat_values in stats.items():
        # Create DataFrame for the current sensor
        stats_df = pd.DataFrame(stat_values, index=[0])

        # Plot heatmap for current sensor
        plt.figure(figsize=(10, 6))
        sns.set(font_scale=1.2)  # Adjust font size
        heatmap = sns.heatmap(stats_df, annot=True, cmap='viridis', fmt='.2f', linewidths=0.5, linecolor='white', cbar=True, annot_kws={"size": 8})
        plt.title(f'Statistical Metrics Heatmap for {sensor_name}', fontsize=16)
        plt.xticks(rotation=45)
        plt.yticks(rotation=0)
        plt.tight_layout()
        plt.show()

    return stats

def main():
    file_path = '/home/wvuser/DATA SET tutorial/webvalley2024_EP_tutorial/webvalley2024/WebValley 2024 Challenge 2/CSES_01_LAP_1_L02_A3_174201_20210324_070216_20210324_073942_000.h5'

    if not os.path.isfile(file_path):
        print(f"Error: File {file_path} does not exist.")
        return

    try:
        ds = xr.open_dataset(file_path, engine='h5netcdf', phony_dims='sort')
    except Exception as e:
        print(f"Error opening file: {e}")
        return

    # List all available sensor names
    available_sensors = list(ds.data_vars.keys())
    print("Available sensor names:")
    for i, sensor in enumerate(available_sensors, 1):
        print(f"{i}. {sensor}")

    # Allow user to select sensor names or exit
    while True:
        selected_sensors_input = input("Enter the numbers of the sensor names you want to analyze, separated by commas (or type 'exit' to quit): ")
        if selected_sensors_input.lower() == 'exit':
            print("Exiting the program.")
            return
        try:
            selected_sensors_indices = [int(i.strip()) - 1 for i in selected_sensors_input.split(",")]
            selected_sensors = [available_sensors[i] for i in selected_sensors_indices]
            break
        except (ValueError, IndexError) as e:
            print("Invalid input. Please enter the numbers corresponding to the sensor names, separated by commas.")

    # List all available statistics
    available_stats = [
        'mean', 'median', 'std_dev', 'min', 'max', 'variance', 
        'skewness', 'kurtosis', 'conf_interval_low', 'conf_interval_high'
    ]
    print("Available statistical calculations:")
    for i, stat in enumerate(available_stats, 1):
        print(f"{i}. {stat}")

    # Allow user to select statistics or exit
    while True:
        selected_stats_input = input("Enter the numbers of the statistics you want to calculate, separated by commas (or type 'exit' to quit): ")
        if selected_stats_input.lower() == 'exit':
            print("Exiting the program.")
            return
        try:
            selected_stats_indices = [int(i.strip()) - 1 for i in selected_stats_input.split(",")]
            selected_stats = [available_stats[i] for i in selected_stats_indices]
            break
        except (ValueError, IndexError) as e:
            print("Invalid input. Please enter the numbers corresponding to the statistics, separated by commas.")

    stats = basic_statistical_analysis_and_plot(file_path, selected_sensors, selected_stats)

    # Print the statistics
    if stats is not None:
        for sensor, stat_values in stats.items():
            print(f"Statistics for {sensor}:")
            for key, value in stat_values.items():
                print(f"{key}: {value}")
            print()

if __name__ == "__main__":
    main()
